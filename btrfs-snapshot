#!/bin/bash
#
# btrfs-snapshot - tool for creating btrfs snapshots
#

declare -r filename=${0##*/} version=%VERSION%

_f_parseopts=parseopts
_d_config=btrfs-snapshot

confdir=true
writable=false

usage() {
    cat <<EOF
btrfs-snapshot $version
usage: $filename [options]

  Options:
   -c, --confdir <dir>              Use alternate config dir (default: /etc/btrfs-snapshot)
   -d, --dest <dir>                 Destination for snapshot
   -h, --help                       Display this message and exit
   -n, --nkeep <number>             Limit number of snapshots to keep (default: no)
   -V, --version                    Display version information and exit
   -s, --subvol <mountpoint>        Mountpoint or dir of subvolume
   -w, --writable                   Create a writable snapshot (default: no)

EOF
}

version() {
    cat <<EOF
btrfs-snapshot $version
EOF
}

check() {
    local -i _code=0
    if [[ $confdir == true ]]; then
        [[ $subvol ]] || {
            echo "$filename: requires variable 'subvol'"
            _code=1
        }
        [[ $dest ]] || {
            echo "$filename: requires variable 'dest'"
        }
    else
        [[ $subvol ]] || {
            echo "$filename: requires option '-s'"
            _code=1
        }
        [[ $dest ]] || {
            echo "$filename: requires option '-d'"
            _code=1
        }
    fi
    [[ $_code == 0 ]] || exit $_code
}

snapshot() {
    mkdir -p "$dest"
    snapshot=$dest/$(date -I)
    [[ ! -d $snapshot ]] || {
        echo "$filename: snapshot on \`$dest' already exists"
        return 1
    }
}

create() {
    if [[ $writable == false ]]; then
        btrfs subvolume snapshot -r "$subvol" "$snapshot"
    else
        btrfs subvolume snapshot "$subvol" "$snapshot"
    fi
}

delete() {
    local _ndel=$(( $(ls "$dest" | wc -l) - nkeep ))
    (( _ndel > 0 )) && {
        local _snapshot=()
        mapfile -t _snapshot < <(ls -d "$dest"/* | head -n $_ndel)
        btrfs subvolume delete "${_snapshot[@]}"
    }
}

main() {
    check
    snapshot || return
    create || return
    if [[ $nkeep ]]; then
        delete
    else
        return 0
    fi
}

. "$_f_parseopts"

trap 'exit 130' INT
trap 'exit 143' TERM

_opt_short='c:d:hn:Vs:w'
_opt_long=('confdir:' 'dest:' 'help' 'nkeep:' 'version' 'subvol:' 'writable')

parseopts "$_opt_short" "${_opt_long[@]}" -- "$@" || exit 1
set -- "${OPTRET[@]}"
unset _opt_short _opt_long OPTRET

while :; do
    case $1 in
        -c|--confdir)
            shift
            _d_config=$1
            ;;
        -d|--dest)
            shift
            dest=$1
            confdir=false
            ;;
        -h|--help)
            usage
            exit 0
            ;;
        -n|--nkeep)
            shift
            declare -i nkeep=$1
            confdir=false
            ;;
        -V|--version)
            version
            exit 0
            ;;
        -s|--subvol)
            shift
            subvol=$1
            confdir=false
            ;;
        -w|--writable)
            writable=true
            ;;
        --)
            shift
            break 2
            ;;
    esac
    shift
done

if [[ $confdir == true ]]; then
    for conf in "$_d_config"/*.conf
    do
        . "$conf"
        main
    done
else
    main
fi

exit

# vim: set ft=sh ts=4 sw=4 et:
