#!/bin/bash
#
# btrfs-snapshot - tool for creating btrfs snapshots
#

declare -r filename=${0##*/} version=%VERSION%

_f_functions=functions
_d_configs=btrfs-snapshot

_optdest= _optsubvol=
_optnkeep=0 _optwritable=0
_optcolor=1
_optconfig=()

usage() {
    cat <<EOF
btrfs-snapshot $version
usage: $filename [options]

  Options:
   -c, --config <config>            Use specified config file in /etc/btrfs-snapshot
   -C, --allconfigs                 Process all config files in /etc/btrfs-snapshot
   -d, --dest <dir>                 Destination for snapshot
   -h, --help                       Display this message and exit
   -n, --nkeep <number>             Number of snapshots to keep, 0 for unlimited (default: 0)
   -N, --nocolor                    Disable colorized output messages
   -V, --version                    Display version information and exit
   -s, --subvol <path>              Path to subvolume
   -w, --writable                   Create a writable snapshot (default: no)

EOF
}

version() {
    cat <<EOF
btrfs-snapshot $version
EOF
}

check_config() {
    if [[ $_optconfig ]]; then
        [[ $subvol ]] || {
            echo "$filename: requires option '-s'"
            _code=1
        }
        [[ $dest ]] || {
            echo "$filename: requires option '-d'"
            _code=1
        }
    else
        [[ $subvol ]] || {
            echo "$filename: requires variable 'subvol'"
            _code=1
        }
        [[ $dest ]] || {
            echo "$filename: requires variable 'dest'"
            _code=1
        }
    fi
}

check_dest() {
    mkdir -p "$dest"
    snapshot=$dest/$(date -I)
    [[ ! -d $snapshot ]] || die "Snapshot in \`$dest' already exists"
}

create_snapshot() {
    if [[ $writable == true ]]; then
        btrfs subvolume snapshot "$subvol" "$snapshot"
    else
        btrfs subvolume snapshot -r "$subvol" "$snapshot"
    fi
}

delete_snapshot() {
    local -i _ndel=$(( $(ls "$dest" | wc -l) - nkeep ))
    (( _ndel <= 0 )) || {
        local _snapshot=()
        mapfile -t _snapshot < <(ls -d "$dest"/* | head -n $_ndel)
        btrfs subvolume delete "${_snapshot[@]}"
    }
}

process_config() {
    check_config
    check_dest
    create_snapshot
    if [[ $_optnkeep ]]; then
        delete_snapshot
    fi
}

. "$_f_parseopts"

trap 'exit 130' INT
trap 'exit 143' TERM

_opt_short='c:Cd:hn:Vs:w'
_opt_long=('config:' 'allconfigs' 'dest:' 'help'
          'nkeep:' 'version' 'subvol:' 'writable')

parseopts "$_opt_short" "${_opt_long[@]}" -- "$@" || exit 1
set -- "${OPTRET[@]}"
unset _opt_short _opt_long OPTRET

while :; do
    case $1 in
        -c|--config)
            shift
            _optconfig=+=("$_d_configs"/"$1")
            ;;
        -C|--allconfigs)
            _optconfig=("$_d_configs"/*.conf)
            [[ -e ${_optpreset[0]} ]] || die "No config files found in $_d_presets"
            ;;
        -d|--dest)
            shift
            _optdest=$1
            ;;
        -h|--help)
            usage
            exit 0
            ;;
        -n|--nkeep)
            shift
            declare -i _optnkeep=$1
            ;;
        -N|--nocolor)
            _optcolor=0
            ;;
        -V|--version)
            version
            exit 0
            ;;
        -s|--subvol)
            shift
            _optsubvol=$1
            ;;
        -w|--writable)
            _optwritable=1
            ;;
        --)
            shift
            break 2
            ;;
    esac
    shift
done

if [[ -t 1 ]] && (( _optcolor )); then
    try_enable_color
fi

if (( ${#_optconfig[*]} )); then
    map process_config "${_optpreset[@]}"
    exit
fi

exit

# vim: set ft=sh ts=4 sw=4 et:
