#!/bin/bash
#
# btrfs-snapshot - tool for creating btrfs snapshots
#

declare -r exename=${0##*/} version=VERSION

_f_parseopts=parseopts

usage() {
    cat <<EOF
btrfs-snapshot $version
usage: $exename [options]

  Options:
   -s, --subvolume <subvolume>      Set subvolume for creating snapshot (default: /root)
   -t, --toplevel <mountpoint>      Set mountpoint of btrfs toplevel (default: /toplevel)
   -n, --nkeep <number>             Limit number of snapshots to keep (default: no)
   -p, --prefix <prefix>            Set prefix of snapshot dir (default: \$toplevel/snapshot)
   -w, --writable                   Create a writable snapshot (default: no)
   -h, --help                       Display this message and exit
   -V, --version                    Display version information and exit

EOF
}

version() {
    cat <<EOF
btrfs-snapshot $version
EOF
}

set_default() {
    toplevel=/toplevel
    subvol=/root
    prefix=$toplevel/snapshot
}

set_and_check_source() {
    source=$toplevel$subvol
    local _errmsg
    _errmsg="$exename: invalid toplevel or subvolume -- source '$source'"
    if [[ ! -e $source ]]; then
        echo "$_errmsg" "does not exist"
        exit 1
    elif [[ ! -d $source ]]; then
        echo "$_errmsg" "is not a directory"
    fi
}

set_and_check_snap() {
    if [[ $subvol = / ]]; then
        dest=$prefix/toplevel
    else
        dest=$prefix$subvol
    fi
    mkdir -p "$dest"
    snapshot=$dest/$(date -I)
    if [[ -d $snapshot ]]; then
        echo "$exename: invalid command -- snapshot already exists"
        exit 1
    fi
}

create_snap() {
    if [[ $rw = true ]]; then
        btrfs subvolume snapshot "$source" "$snapshot"
    else
        btrfs subvolume snapshot -r "$source" "$snapshot"
    fi
}

delete_snap() {
    local _ndel=$(( $(ls "$dest" | wc -l) - nkeep ))
    (( _ndel > 0 )) && {
        local _snapshot=()
        mapfile -t _snapshot < <(ls -d "$dest"/* | head -n $_ndel)
        btrfs subvolume delete "${_snapshot[@]}"
    }
}

. "$_f_parseopts"

trap 'exit 130' INT
trap 'exit 143' TERM

_opt_short='s:t:n:p:whV'
_opt_long=('subvolume:' 'toplevel:' 'nkeep:' 'prefix:' 'writable' 'help' 'version')

parseopts "$_opt_short" "${_opt_long[@]}" -- "$@" || exit 1
set -- "${OPTRET[@]}"
unset _opt_short _opt_long OPTRET

set_default

while :; do
    case $1 in
        -s|--subvolume)
            shift
            subvol=$1
            ;;
        -t|--toplevel)
            shift
            toplevel=$1
            ;;
        -n|--nkeep)
            shift
            declare -i nkeep=$1
            ;;
        -p|--prefix)
            shift
            prefix=$1
            ;;
        -w|--writable)
            rw=true
            ;;
        -h|--help)
            usage
            exit 0
            ;;
        -V|--version)
            version
            exit 0
            ;;
        --)
            shift
            break 2
            ;;
    esac
    shift
done

set_and_check_source
set_and_check_snap
create_snap

if [[ $nkeep ]]; then
    delete_snap
fi

exit

# vim: set ft=sh ts=4 sw=4 et:
